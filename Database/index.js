// 몽고DB는 강력하고 유연하며 확장성 높은 범용 데이터베이스입니다.
// 몽고DB는 JSON 기반의 문서(Document) 형태로 데이터를 저장하는 NoSQL 데이터베이스입니다.
// 몽고DB는 관계형 데이터베이스가 아니라 도큐먼트 지향 데이터베이스입니다.
// 도큐먼트 지향 데이터베이스에서는 행 개념 대신에 보다 유연한 모델인 도큐먼트(document)를 사용합니다.

// - 몽고DB 데이터의 기본 단위는 도큐먼트이며, 이는 관계형 데이터베이스의 행과 유사합니다.
// - 같은 맥락에서 컬렉션(Collection)은 동적 스키마(Dynamic Schema)가 있는 테이블과 같습니다.
// - 몽고DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅합니다.
// - 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 "_id"를 가집니다.
// - 몽고DB는 몽고 쉘(The mongo Shell)이라는 간단하지만 강력한 도구와 함께 배포됩니다.
//   mongo 셀은 몽고DB인스턴스를 관리하고 몽고DB 쿼리 언어로 데이터를 조작하기 위한 내장 지원을 제공합니다.
//   또한, 사용자가 다양한 목적으로 자신의 스크립트를 만들고 로드할 수 있는 완전한 기능의 자바스크립트 해석가(JavaScript Interpreter)입니다.

// 1. 도큐먼트
// 몽고DB의 핵심은 정렬된 키와 연결된 값의 집합으로 이루어진 도큐먼트입니다.
// 도큐먼트는 키(key)와 값(value) 이 쌍으로 묶어 있는 데이터 덩어리입니다.
// 이 한 덩어리가 몽고DB에서 데이터의 기본 단위가 됩니다.

{ "greeting": "Hello, world!" }

// 위 간단한 도큐먼트는 "greeting"이라는 키에 연결된 "Hello, world!"라는 값을 가집니다.
// "greeting"이라는 이름에 데이터에 "Hello, world!"라는 값을 저장한 것을 의미합니다.

// 도큐먼트는 여러 개의 키-값 쌍을 가질 수도 있습니다.
{
  "name": "홍길동",
  "age": 30,
  "email": "hong@example.com"
}

// 2. 컬렉션
// 컬렉션은 도큐먼트의 모음입니다.
// 몽고DB의 도큐먼트가 관계형 데이터베이스의 행에 대응된다면 컬렉션은 테이블에 대응된다고 볼 수 있습니다.
// 다시 말해, 컬렉션은 여러 개의 도큐먼트가 모여 있는 그룹입니다.
// 쉽게 말해, "비슷한 종류의 데이터(문서)들을 한 곳에 모아둔 상자"라고 생각하면 됩니다.

// 예를 들어, 다음과 같은 여러 사람 정보를 저장한다고 해보겠습니다.
{ "name": "홍길동", "age": 30 }
{ "name": "이몽룡", "age": 25 }
{ "name": "성춘향", "age": 22 }

// 이 세 개의 문서(document)를 users라는 하나의 컬렉션(Collection) 안에 넣을 수 있습니다.
users 컬렉션
 ├─ { "name": "홍길동", "age": 30 }
 ├─ { "name": "이몽룡", "age": 25 }
 └─ { "name": "성춘향", "age": 22 }

// 2.1 동적 스키마
// 컬렉션은 동적 스키마를 가집니다.
// 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다는 의미입니다.

// 예를 들어, 다음과 같은 users 컬렉션에 들어 있는 문서들입니다.
{ "name": "홍길동", "age": 30 }
{ "name": "이몽룡", "email": "lee@example.com" }
{ "name": "성춘향", "age": 22, "address": "남원" }

// 첫 번째 문서에는 age가 있고,
// 두 번째 문서에는 email이 있고,
// 세 번째 문서에는 address가 있습니다..

// 그런데 MongoDB는 이걸 전혀 문제 삼지 않습니다.
// 같은 컬렉션(users) 안에 있어도 OK

// 하지만 “실무”에서는 별도의 컬렉션이 꼭 필요합니다
// MongoDB는 유연하지만, 데이터를 논리적으로 구분하는 단위가 컬렉션입니다.
// 아래 이유들을 보면 왜 컬렉션을 나누는지가 분명해집니다.

// 2.1.1 데이터의 "의미적 구분"을 위해
// 컬렉션은 단순히 저장 공간이 아니라, 데이터의 성격을 구분하는 논리적 단위입니다.
// 예를 들어 다음 세 가지 종류의 데이터를 모두 하나의 컬렉션에 넣는다면 혼란스럽겠죠.

// users 컬렉션 → 사용자 정보
// products 컬렉션 → 상품 정보
// orders 컬렉션 → 주문 정보

// 만약 이걸 전부 data라는 한 컬렉션에 넣는다면,

// 어떤 문서가 사용자고,
// 어떤 문서가 상품이며,
// 어떤 문서가 주문인지

// 매번 조건문으로 구분해야 합니다. → 관리, 쿼리, 인덱싱 모두 복잡해집니다.

// 2.1.2 쿼리 효율성과 인덱싱 성능
// MongoDB의 쿼리 엔진은 컬렉션 단위로 인덱스(index)를 관리합니다.
// 컬렉션마다 인덱스를 따로 최적화할 수 있기 때문에,
// 서로 다른 구조의 데이터를 같은 컬렉션에 넣으면 인덱스가 제대로 작동하지 않거나 비효율적일 수 있습니다.

// 예를 들어 users 컬렉션에는 email 필드 인덱스가 유용하지만,
// products 문서에는 email이 없죠.
// 같이 있으면 불필요한 인덱스 낭비입니다.

// 2.1.3 접근 권한과 보안
// MongoDB는 컬렉션 단위로 권한 제어(Role-Based Access) 를 설정할 수 있습니다.

// users 컬렉션 → 고객 데이터 (개인정보)
// orders 컬렉션 → 거래 데이터 (민감한 결제정보)

// → 같은 컬렉션에 있으면 권한 분리가 어렵고, 보안 위험이 커집니다.

// 2.1.4 스토리지 관리 및 샤딩(Sharding)
// MongoDB는 샤딩(데이터 분산 저장)을 컬렉션 단위로 수행합니다.
// 즉, 컬렉션은 물리적인 분산 저장의 최소 단위이기도 합니다.

// 서로 다른 종류의 데이터를 한 컬렉션에 넣으면,
// 특정 필드로 샤딩하기 어려워지고,
// 데이터 분산이 비효율적이 됩니다.

// 2.1.5 유지보수와 가독성
// 컬렉션을 구분하면 개발자나 운영자가 데이터를 훨씬 직관적으로 다룰 수 있습니다.

// 로그 데이터 → logs
// 사용자 데이터 → users
// 상품 데이터 → products

// 이렇게 분리하면 쿼리, 백업, 분석, 모니터링이 모두 단순해집니다.

// ✅ MongoDB 핵심 요약
// - 데이터의 기본 단위는 도큐먼트(Document)
// - 도큐먼트들이 모여 컬렉션(Collection)을 이룸
// - 컬렉션은 동적 스키마를 가지며 구조가 자유로움
// - 하지만 실무에서는 데이터의 성격에 따라 컬렉션을 구분해야 함
// - MongoDB는 JSON 기반으로 유연하고 확장성이 뛰어난 NoSQL 데이터베이스임
