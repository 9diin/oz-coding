// 쿼리

// 1. find 소개
// 몽고 DB에서 find 함수는 쿼리에 사용합니다.
// 쿼리는 컬렉션에서 도큐먼트의 서브셋(빈 컬렉션부터 컬렉션 전체까지)을 반환합니다.

// 빈 쿼리 도큐먼트(즉 {})는 컬렉션 내 모든 것과 일치한다.
// 매개변수에 쿼리 도큐먼트가 없으면 find 함수는 빈 쿼리 도큐먼트 {}로 인식합니다.
// 따라서 다음 명령은 컬렉션 c의 모든 도큐먼트와 일치하므로 컬렉션 c 내 모든 도큐먼트를 반환합니다.

db.c.find();

// 쿼리 도큐먼트에 여리 키/값 쌍을 추가해 검색을 제한할 수 있습니다.
// 대부분의 데이터형에서 간단히 작동하며 정수형은 정수형에, 불리언형은 불리언형에, 문자열형은 문자열형에 일치합니다.
// 간단한 데이터형은 찾으려는 값만 지정하면 쉽게 쿼리할 수 있습니다.

// 예를 들어, "age"가 27인 모든 도큐먼트를 찾으려면 키/값 쌍을 쿼리 도큐먼트에 다음처럼 추가합니다.

db.users.find({ `age`: 27 });

// "username" 키 값이 "joe"인 경우와 같이 문자열형이 일치하는 도큐먼트를 찾고 싶다면 다음과 같이 키/값 쌍을 사용합니다.
db.users.find({ "username": "joe" })

// 쿼리 도큐먼트에 여러 개의 키/값 쌍을 추가할 수 있으며 '조건 1 AND 조건 2 AND ... AND 조건N'으로 해석된다.
db.users.find({ "username": "joe", "age": 27 })

// 1.1 반환받을 키 지정
// 때때로 반환받은 도큐먼트 내 키/값 정보가 모두 필요하지는 않을 수 있습니다.
// 그럴 때는 find(또는 findOne)의 두 번째 매개변수에 원하는 키를 지정하면 됩니다.
// 이는 네트워크상의 데이터 전송량과 클라이언트 측에서 도큐먼트를 디코딩하는데 드는 시간과 메모리를 줄여줍니다.

// 예를 들어, 사용자 정보 컬렉션에서 "username"과 "email" 키의 값만 원할 때는 다음과 같이 쿼리합니다.
db.users.find({}, { "username": 1, "email": 1})

// 예제에서 볼 수 있듯 "_id" 키는 지정하지 않아도 항상 반환됩니다.
// 또한 두 번째 매개변수를 사용해서 특정 키/값 쌍을 제외한 결과를 얻을 수도 있습니다.
// 예를 들어 다양한 키가 있는 도큐먼트에서 "fatal_weakness" 키 값을 쓸 일이 전혀 없다면 다음과 같이 제외시킨다.
db.users.find({}, { "fatal_weakness": 0 })

// "_id" 반환을 제외할 수도 있다.
db.users.find({}, { "_id": 0 })

// 1.2 제약 사항
// 쿼리에는 몇 가지 제약이 있다. 데이터베이스에서 쿼리 도큐먼트 값은 반드시 상수여야 한다.
// (물론 작성한 코드 내에서는 일반 변수여도 상관없다.) 이는 도큐먼트 내 다른 키의 값을 참조할 수 없음 의미한다.
// 예를 들어 재고 도큐먼트에 재고 수량 키 "in_stock"과 판매 수량 키 "num_sold"가 있으면 키 값을 다음과 같은 쿼리로 비교할 수 있다.
db.users.find({ "in_stock": "this.num_sold" }) // 작동하지 않음

// 2. 쿼리 조건
// 2.1 쿼리 조건절
// <, <=, >, >= 에 해당하는 비교 연산자는 각각 "$lt", "$lte", "$gt", "$gte" 입니다.
// 예를 들어 18세에서 30세 사이의 사용자를 찾으려면 다음과 같이 쿼리한다.
db.users.find({ "age": { "$gte": 18, "$lte": 30 } })

// 키 값이 특정 값과 일치하지 않는 도큐먼트를 찾는 데는 "not equal"을 나타내는 "$ne"를 사용한다.
// 사용자명이 "joe"가 아닌 사용자를 모두 찾으려면 다음과 같이 쿼리한다.
db.users.find({ "username": { "$ne": "joe" } })

// 2.2 OR 쿼리
// 몽고DB에서 OR 쿼리에는 두 가지 방법이 있습니다.
// "$in"은 하나의 키를 다양한 값과 비교하는 쿼리에 사용합니다.
// "$or"은 더 일반적이며, 여러 키를 주어진 값과 비교하는 쿼리에 사용합니다.

// 하나의 키에 일치시킬 값이 여러 개 있다면 "$in"에 조건 배열을 사용합니다.
// 예를 들어 추첨 당첨자를 뽑는 상황에서 당첨 번호가 725, 542, 390이라고 가정해보겠습니다.
// 세 도큐먼트를 모두 찾으려면 다음과 같이 쿼리합니다.
db.raffle.find({ "ticket_no": { "$in": [ 725, 542, 390 ] }})

// "$in"은 매우 유연해 여러 개의 값을 쓸 수 있을 뿐 아니라 서로 다른 데이터형도 쓸 수 있습니다.
//  예를 들어 사용자 ID에 번호 대신 이름을 쓰도록 점진적으로 이전하고 있다면, 두 조건 중 하나라도 맞는 도큐먼트를 찾도록 쿼리합니다.
db.users.find({ "user_id": { "$in": [ 12345, "joe" ]} })

// 위 쿼리는 "user_id"가 12345 이거나 "joe"인 도큐먼트를 찾습니다.
// "$in"의 조건 배열에 값이 하나만 주어지면 바로 일치하는 것을 찾습니다.
// 예를 들어 { ticket_no: { $in : [ 725 ] }}로 쿼리한 도큐먼트는 { ticket_no: 725 }로 쿼리한 도큐먼트와 일치합니다.

// "$nin"은 "$in"과 반대로 배열 내 조건과 일치하지 않는 도큐먼트를 반환합니다.
// 추첨해서 당첨되지 않은 사람을 모두 반환받고 싶으면 다음과 같이 쿼리합니다.
db.raffle.find({ "ticket_no": { "$nin": [ 725, 542, 390 ] } })

// "$in"은 하나의 킹에 대해 OR 쿼리를 하는데, "ticket_no"가 725이거나 "winner"가 true인 도큐먼트를 찾고 싶을 땐 어떻게 해야 할까?
// 이런 유형의 쿼리에는 "$or" 연산자를 사용합니다.
// "$or"은 가능한 조건들의 배열을 취합니다.
db.raffle.find({ "$or": [{ "ticket_no": 725 }, { "winder": true }] })

// "$or"은 다른 조건절도 포함할 수 있습니다.
// 예를 들어 "ticket_no"가 세 번호 중 적어도 하나와 일치하거나 "winner"가 true인 경우를 찾는다면 다음과 같이 쿼리합니다.
db.raffle.find({ "$or": [{ "ticket_no": { "$in": [ 725, 542, 390 ] }}, { "winner": true }] })

// 일반적인 AND 쿼리에서는 최소한의 인수로 최적의 결과(범위를 좁힌 결과)를 추려내야 합니다.
// OR 쿼리는 반대인데, 첫 번째 인수가 일치하는 도큐먼트가 많을 수록 효율적이다.

// 2.3 $not
// $not은 메타 조건절이며 어떤 조건에도 적용할 수 있습니다.
// 예를 들어 나머지 연산자 "$mod"를 생각해봅시다.
// "$mod"는 키의 값을 첫 번째 값으로 나눈 후 그 나머지 값의 조건을 두 번째 값으로 기술하는 연산자입니다.
db.users.find({ "id_num": { "$mod": [ 5, 1 ] } })

// 위 쿼리는 "id_num"의 값이 1, 6, 11, 16 등인 사용자를 반환합니다.
// "id_num"이 2, 3, 4, 5, 7, 8, 9, 10, 12 등인 사용자를 받으려면 "$not"을 사용합니다.
db.users.find({ "id_num": { "$not": [ 5, 1 ] } })
